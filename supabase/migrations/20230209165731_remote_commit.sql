CREATE INDEX refresh_token_session_id ON auth.refresh_tokens USING btree (session_id);

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION auth.set_user_role()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin

    if new.invited_at = null then
        select set_claim(new.id, 'react_admin', 'false'); 
    else 
        select set_claim(new.id, 'react_admin', 'true'); 
    end if;
end;$function$
;

CREATE OR REPLACE FUNCTION auth.email()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(
		nullif(current_setting('request.jwt.claim.email', true), ''),
		(nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
	)::text
$function$
;

CREATE OR REPLACE FUNCTION auth.role()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(
		nullif(current_setting('request.jwt.claim.role', true), ''),
		(nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
	)::text
$function$
;

CREATE OR REPLACE FUNCTION auth.uid()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(
		nullif(current_setting('request.jwt.claim.sub', true), ''),
		(nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
	)::uuid
$function$
;

CREATE TRIGGER set_admin_role_trigger AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION set_admin_role();


create extension if not exists "pg_cron" with schema "extensions";

create extension if not exists "pg_net" with schema "extensions";


create table "public"."chats" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now()
);


alter table "public"."chats" enable row level security;

create table "public"."drives" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "driver_id" bigint not null,
    "start" character varying not null,
    "start_time" timestamp with time zone not null,
    "end" character varying not null,
    "end_time" timestamp with time zone not null,
    "seats" smallint not null,
    "cancelled" boolean not null default false,
    "hide_in_list_view" boolean not null default false,
    "start_lat" real not null,
    "start_lng" real not null,
    "end_lat" real not null,
    "end_lng" real not null,
    "recurring_drive_id" bigint
);


alter table "public"."drives" enable row level security;

create table "public"."messages" (
    "id" bigint generated by default as identity not null,
    "sender_id" bigint not null,
    "content" character varying,
    "created_at" timestamp with time zone default now(),
    "read" boolean not null default false,
    "chat_id" bigint not null
);


alter table "public"."messages" enable row level security;

create table "public"."profile_features" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "profile_id" bigint not null,
    "feature" smallint,
    "rank" smallint
);


alter table "public"."profile_features" enable row level security;

create table "public"."profiles" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "username" text,
    "email" character varying,
    "auth_id" uuid not null,
    "description" text,
    "birth_date" timestamp with time zone,
    "surname" text,
    "name" text,
    "gender" smallint,
    "avatar_url" text
);


alter table "public"."profiles" enable row level security;

create table "public"."recurring_drives" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "driver_id" bigint not null,
    "start" text not null,
    "start_time" time without time zone not null,
    "end" text not null,
    "end_time" time without time zone not null,
    "seats" smallint not null,
    "start_lat" real not null,
    "start_lng" real not null,
    "end_lat" real not null,
    "end_lng" real not null,
    "recurrence_rule" text,
    "stopped_at" timestamp with time zone
);


alter table "public"."recurring_drives" enable row level security;

create table "public"."reports" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "offender_id" bigint not null,
    "reporter_id" bigint not null,
    "category" smallint not null,
    "text" text
);


alter table "public"."reports" enable row level security;

create table "public"."reviews" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "rating" smallint not null,
    "text" text default ''::text,
    "writer_id" bigint not null,
    "receiver_id" bigint not null,
    "comfort_rating" smallint,
    "safety_rating" smallint,
    "reliability_rating" smallint,
    "hospitality_rating" smallint
);


alter table "public"."reviews" enable row level security;

create table "public"."ride_events" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "ride_id" bigint not null,
    "category" smallint not null,
    "read" boolean not null default false
);


alter table "public"."ride_events" enable row level security;

create table "public"."rides" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "rider_id" bigint not null,
    "drive_id" bigint not null,
    "seats" smallint not null default '1'::smallint,
    "start" character varying not null,
    "start_time" timestamp with time zone not null,
    "end" character varying not null,
    "end_time" timestamp with time zone not null,
    "price" double precision not null,
    "status" smallint not null,
    "hide_in_list_view" boolean not null default false,
    "start_lat" real not null,
    "end_lat" real not null,
    "end_lng" real not null,
    "start_lng" real not null,
    "chat_id" bigint
);


alter table "public"."rides" enable row level security;

CREATE UNIQUE INDEX chats_pkey ON public.chats USING btree (id);

CREATE UNIQUE INDEX drives_pkey ON public.drives USING btree (id);

CREATE UNIQUE INDEX messages_pkey ON public.messages USING btree (id);

CREATE UNIQUE INDEX profile_features_pkey ON public.profile_features USING btree (id);

CREATE UNIQUE INDEX recurring_drives_pkey ON public.recurring_drives USING btree (id);

CREATE UNIQUE INDEX reports_pkey ON public.reports USING btree (id);

CREATE UNIQUE INDEX reviews_pkey ON public.reviews USING btree (id);

CREATE UNIQUE INDEX rider_events_pkey ON public.ride_events USING btree (id);

CREATE UNIQUE INDEX rides_pkey ON public.rides USING btree (id);

CREATE UNIQUE INDEX users_email_key ON public.profiles USING btree (email);

CREATE UNIQUE INDEX users_pkey ON public.profiles USING btree (id);

alter table "public"."chats" add constraint "chats_pkey" PRIMARY KEY using index "chats_pkey";

alter table "public"."drives" add constraint "drives_pkey" PRIMARY KEY using index "drives_pkey";

alter table "public"."messages" add constraint "messages_pkey" PRIMARY KEY using index "messages_pkey";

alter table "public"."profile_features" add constraint "profile_features_pkey" PRIMARY KEY using index "profile_features_pkey";

alter table "public"."profiles" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."recurring_drives" add constraint "recurring_drives_pkey" PRIMARY KEY using index "recurring_drives_pkey";

alter table "public"."reports" add constraint "reports_pkey" PRIMARY KEY using index "reports_pkey";

alter table "public"."reviews" add constraint "reviews_pkey" PRIMARY KEY using index "reviews_pkey";

alter table "public"."ride_events" add constraint "rider_events_pkey" PRIMARY KEY using index "rider_events_pkey";

alter table "public"."rides" add constraint "rides_pkey" PRIMARY KEY using index "rides_pkey";

alter table "public"."drives" add constraint "drives_driver_id_fkey" FOREIGN KEY (driver_id) REFERENCES profiles(id) not valid;

alter table "public"."drives" validate constraint "drives_driver_id_fkey";

alter table "public"."drives" add constraint "drives_recurring_drive_id_fkey" FOREIGN KEY (recurring_drive_id) REFERENCES recurring_drives(id) not valid;

alter table "public"."drives" validate constraint "drives_recurring_drive_id_fkey";

alter table "public"."drives" add constraint "seats_validator" CHECK ((seats >= 1)) not valid;

alter table "public"."drives" validate constraint "seats_validator";

alter table "public"."messages" add constraint "messages_chat_id_fkey" FOREIGN KEY (chat_id) REFERENCES chats(id) not valid;

alter table "public"."messages" validate constraint "messages_chat_id_fkey";

alter table "public"."messages" add constraint "messages_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES profiles(id) not valid;

alter table "public"."messages" validate constraint "messages_sender_id_fkey";

alter table "public"."profile_features" add constraint "feature_validator" CHECK (((feature >= 0) AND (feature <= 14))) not valid;

alter table "public"."profile_features" validate constraint "feature_validator";

alter table "public"."profile_features" add constraint "profile_features_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) not valid;

alter table "public"."profile_features" validate constraint "profile_features_profile_id_fkey";

alter table "public"."profile_features" add constraint "rank_validator" CHECK ((rank >= 0)) not valid;

alter table "public"."profile_features" validate constraint "rank_validator";

alter table "public"."profiles" add constraint "gender_validator" CHECK (((gender IS NULL) OR ((gender >= 0) AND (gender <= 2)))) not valid;

alter table "public"."profiles" validate constraint "gender_validator";

alter table "public"."profiles" add constraint "profiles_auth_id_fkey" FOREIGN KEY (auth_id) REFERENCES auth.users(id) not valid;

alter table "public"."profiles" validate constraint "profiles_auth_id_fkey";

alter table "public"."profiles" add constraint "users_email_key" UNIQUE using index "users_email_key";

alter table "public"."recurring_drives" add constraint "recurring_drives_driver_id_fkey" FOREIGN KEY (driver_id) REFERENCES profiles(id) not valid;

alter table "public"."recurring_drives" validate constraint "recurring_drives_driver_id_fkey";

alter table "public"."recurring_drives" add constraint "seats_validator" CHECK ((seats >= 1)) not valid;

alter table "public"."recurring_drives" validate constraint "seats_validator";

alter table "public"."reports" add constraint "category_validator" CHECK (((category >= 0) AND (category <= 5))) not valid;

alter table "public"."reports" validate constraint "category_validator";

alter table "public"."reports" add constraint "reports_offender_id_fkey" FOREIGN KEY (offender_id) REFERENCES profiles(id) not valid;

alter table "public"."reports" validate constraint "reports_offender_id_fkey";

alter table "public"."reports" add constraint "reports_reporter_id_fkey" FOREIGN KEY (reporter_id) REFERENCES profiles(id) not valid;

alter table "public"."reports" validate constraint "reports_reporter_id_fkey";

alter table "public"."reviews" add constraint "reviews_receiver_id_fkey" FOREIGN KEY (receiver_id) REFERENCES profiles(id) not valid;

alter table "public"."reviews" validate constraint "reviews_receiver_id_fkey";

alter table "public"."reviews" add constraint "reviews_writer_id_fkey" FOREIGN KEY (writer_id) REFERENCES profiles(id) not valid;

alter table "public"."reviews" validate constraint "reviews_writer_id_fkey";

alter table "public"."ride_events" add constraint "category_validator" CHECK (((category >= 0) AND (category <= 5))) not valid;

alter table "public"."ride_events" validate constraint "category_validator";

alter table "public"."ride_events" add constraint "ride_events_ride_id_fkey" FOREIGN KEY (ride_id) REFERENCES rides(id) not valid;

alter table "public"."ride_events" validate constraint "ride_events_ride_id_fkey";

alter table "public"."rides" add constraint "price_validator" CHECK ((price >= (0)::double precision)) not valid;

alter table "public"."rides" validate constraint "price_validator";

alter table "public"."rides" add constraint "rides_chat_id_fkey" FOREIGN KEY (chat_id) REFERENCES chats(id) not valid;

alter table "public"."rides" validate constraint "rides_chat_id_fkey";

alter table "public"."rides" add constraint "rides_original_drive_id_fkey" FOREIGN KEY (drive_id) REFERENCES drives(id) not valid;

alter table "public"."rides" validate constraint "rides_original_drive_id_fkey";

alter table "public"."rides" add constraint "rides_original_rider_id_fkey" FOREIGN KEY (rider_id) REFERENCES profiles(id) not valid;

alter table "public"."rides" validate constraint "rides_original_rider_id_fkey";

alter table "public"."rides" add constraint "seats_validator" CHECK ((seats >= 1)) not valid;

alter table "public"."rides" validate constraint "seats_validator";

alter table "public"."rides" add constraint "status_validator" CHECK (((status >= 1) AND (status <= 6))) not valid;

alter table "public"."rides" validate constraint "status_validator";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.approve_ride(ride_id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  if is_ride_update_allowed(ride_id)
  then 
  update rides
  /* status = 2 is the approved status for a ride */
  set status = 2
  where id = ride_id;
  end if;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.create_chat()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
  insert into chats
  default values
  returning id into new.chat_id;

  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.create_drives_from_recurring()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
	recurring_drive RECORD;
	drive_start_time TIMESTAMP;
	drive_end_time TIMESTAMP;
BEGIN
	FOR recurring_drive IN
		SELECT
			*
		FROM
			recurring_drives
		WHERE
			_rrule.rruleset (recurrence_rule) @> (now()::timestamp + interval '30 days') AND
			stopped_at IS NULL
	LOOP
		drive_start_time = CURRENT_DATE + interval '30 days' + recurring_drive.start_time;
		drive_end_time = CURRENT_DATE + interval '30 days' + recurring_drive.end_time;
		IF recurring_drive.start_time > recurring_drive.end_time THEN
			drive_end_time = drive_end_time + interval '1 day';
		END IF;
		
	
		INSERT INTO drives (driver_id, "start", start_time, "end", end_time, seats, start_lat, start_lng, end_lat, end_lng, recurring_drive_id)
		VALUES (recurring_drive.driver_id, recurring_drive."start", drive_start_time, recurring_drive."end", drive_end_time, recurring_drive.seats, recurring_drive.start_lat, recurring_drive.start_lng, recurring_drive.end_lat, recurring_drive.end_lng, recurring_drive.id);
	END LOOP;
	RETURN;
END
$function$
;

CREATE OR REPLACE FUNCTION public.create_ride_event()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
  
  if old is null or new.status != old.status then
    insert into ride_events(ride_id,category)
    values(
      new.id,
      /* the corresponding status of a event is the ride status -1 since there is now event for preview and the ride status therrefore begins with one in Supabase*/
      new.status -1
    );
  end if;
  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.delete_claim(uid uuid, claim text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN 'error: access denied';
      ELSE        
        update auth.users set raw_app_meta_data = 
          raw_app_meta_data - claim where id = uid;
        return 'OK';
      END IF;
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_claim(uid uuid, claim text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    DECLARE retval jsonb;
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN '{"error":"access denied"}'::jsonb;
      ELSE
        select coalesce(raw_app_meta_data->claim, null) from auth.users into retval where id = uid::uuid;
        return retval;
      END IF;
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_claims(uid uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    DECLARE retval jsonb;
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN '{"error":"access denied"}'::jsonb;
      ELSE
        select raw_app_meta_data from auth.users into retval where id = uid::uuid;
        return retval;
      END IF;
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_claim(claim text)
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(nullif(current_setting('request.jwt.claims', true), '')::jsonb -> 'app_metadata' -> claim, null)
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_claims()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(nullif(current_setting('request.jwt.claims', true), '')::jsonb -> 'app_metadata', '{}'::jsonb)::jsonb
$function$
;

CREATE OR REPLACE FUNCTION public.is_claims_admin()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
  BEGIN
    IF session_user = 'authenticator' THEN
     return false;
    ELSE -- not a user session, probably being called from a trigger or something
      return true;
    END IF;
  END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_ride_update_allowed(ride_id integer)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$/* Users are allowed to update the status of rides where they are the driver */
begin
  return (select profiles.id from profiles where profiles.auth_id = auth.uid()) = 
  (select drives.driver_id from drives where id = (select rides.drive_id from rides where id = ride_id));
end;
$function$
;

CREATE OR REPLACE FUNCTION public.mark_message_as_read(message_id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
  update messages
  set read = true
  where id = message_id;
end;$function$
;

CREATE OR REPLACE FUNCTION public.mark_ride_event_as_read(ride_event_id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
  update ride_events
  set read = true
  where id = ride_event_id;
end;$function$
;

CREATE OR REPLACE FUNCTION public.recurring_drive_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	next_date DATE;
	recurring_drive RECORD := new;
	drive_start_time TIMESTAMP;
	drive_end_time TIMESTAMP;
BEGIN
	FOR next_date IN
		SELECT next_dates.d
		FROM generate_series(
			CURRENT_DATE,
			CURRENT_DATE + INTERVAL '30 days',
			INTERVAL '1 day'
		) next_dates(d)
		WHERE _rrule.rruleset(recurring_drive.recurrence_rule) @> next_dates.d
	LOOP
		drive_start_time = next_date + recurring_drive.start_time;
		drive_end_time = next_date + recurring_drive.end_time;
		IF recurring_drive.start_time > recurring_drive.end_time THEN
			drive_end_time = drive_end_time + interval '1 day';
		END IF;
		
	
		INSERT INTO drives (driver_id, "start", start_time, "end", end_time, seats, start_lat, start_lng, end_lat, end_lng, recurring_drive_id)
		VALUES (recurring_drive.driver_id, recurring_drive."start", drive_start_time, recurring_drive."end", drive_end_time, recurring_drive.seats, recurring_drive.start_lat, recurring_drive.start_lng, recurring_drive.end_lat, recurring_drive.end_lng, recurring_drive.id);
	END LOOP;
  RETURN new;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.recurring_drive_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	day_offset INTERVAL;
	next_date DATE;	
	drive_start_time TIMESTAMP;
	drive_end_time TIMESTAMP;
BEGIN
	IF new.stopped_at IS NOT NULL AND old.stopped_at IS NULL THEN
		UPDATE drives
		SET cancelled = TRUE
		WHERE drives.recurring_drive_id = new.id AND drives.start_time > CURRENT_TIMESTAMP;
		RETURN NEW;
	END IF;

	IF new.recurrence_rule != old.recurrence_rule THEN
		UPDATE drives
		SET cancelled = TRUE
		WHERE drives.recurring_drive_id = new.id AND drives.start_time > CURRENT_TIMESTAMP AND NOT(_rrule.rruleset (new.recurrence_rule) @> DATE(drives.start_time));

		FOR next_date IN
			SELECT next_dates.d
			FROM generate_series(
				CURRENT_DATE,
				CURRENT_DATE + INTERVAL '30 days',
				INTERVAL '1 day'
			) next_dates(d)
			WHERE _rrule.rruleset(new.recurrence_rule) @> next_dates.d
			AND NOT EXISTS(
				SELECT *
				FROM drives
				WHERE drives.recurring_drive_id = new.id AND DATE(next_dates.d) = DATE(drives.start_time)
			)
		LOOP
			drive_start_time = next_date + new.start_time;
			drive_end_time = next_date + new.end_time;
			IF new.start_time > new.end_time THEN
				drive_end_time = drive_end_time + interval '1 day';
			END IF;
			
		
			INSERT INTO drives (driver_id, "start", start_time, "end", end_time, seats, start_lat, start_lng, end_lat, end_lng, recurring_drive_id)
			VALUES (new.driver_id, new."start", drive_start_time, new."end", drive_end_time, new.seats, new.start_lat, new.start_lng, new.end_lat, new.end_lng, new.id);
		END LOOP;
	END IF;

  	RETURN new;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reject_ride(ride_id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  if is_ride_update_allowed(ride_id)
  then 
  update rides
  /* status = 3 ist the rejected status for a ride in the app */
  set status = 3
  where id = ride_id;
  end if;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.ride_event_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin

  update public.ride_events 
  set read = true
  where ride_id = new.ride_id;
      
  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.set_admin_role()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$/* users are admins if they get invited into supabase */
begin
    if new.invited_at notnull then 
     update auth.users
    set raw_app_meta_data = raw_app_meta_data || jsonb_build_object('admin', 'true')
    where id = new.id;
    else 
      update auth.users
    set raw_app_meta_data = raw_app_meta_data || jsonb_build_object('admin', 'false')
    where id = new.id;
    end if;
    return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.set_claim(uid uuid, claim text, value jsonb)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN 'error: access denied';
      ELSE        
        update auth.users set raw_app_meta_data = 
          raw_app_meta_data || 
            json_build_object(claim, value)::jsonb where id = uid;
        return 'OK';
      END IF;
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_ride_status()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
    if new.cancelled = True and old.cancelled = False then 
      update public.rides 
      /* status = 4 is the cancelledByDriver status for rides in the app */
      set status = 4
      where rides.drive_id = new.id 
      /* the update  is only for rides with status = 2 (approved rides)*/
        and (rides.status = 2);
      update public.rides 
      /* status = 3 is the rejected status for drives in the app */
      set status = 3
      where rides.drive_id = new.id 
      /* the status is only pdated when status = 1 (pending ride) */
        and (rides.status = 1);
    end if;
    return new;
end;$function$
;

create policy "admins have full control"
on "public"."chats"
as permissive
for all
to authenticated
using ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb))
with check ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb));


create policy "users can select chats from rides they can see"
on "public"."chats"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM rides
  WHERE (rides.chat_id = chats.id))));


create policy "Enable read access for all users"
on "public"."drives"
as permissive
for select
to public
using (true);


create policy "Users can only create drives for themselves"
on "public"."drives"
as permissive
for insert
to authenticated
with check ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = drives.driver_id))));


create policy "Users can update their own drives"
on "public"."drives"
as permissive
for update
to authenticated
using ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = drives.driver_id))))
with check ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = drives.driver_id))));


create policy "admins have full control"
on "public"."drives"
as permissive
for all
to authenticated
using ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb))
with check ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb));


create policy "Users can insert Messages for themselves in their own chats"
on "public"."messages"
as permissive
for insert
to authenticated
with check (((sender_id IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.auth_id = auth.uid()))) AND (EXISTS ( SELECT 1
   FROM chats
  WHERE (chats.id = messages.chat_id)))));


create policy "admins have full control"
on "public"."messages"
as permissive
for all
to authenticated
using ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb))
with check ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb));


create policy "users can select messages from their chats"
on "public"."messages"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM chats
  WHERE (chats.id = messages.chat_id))));


create policy "Enable read access for all users"
on "public"."profile_features"
as permissive
for select
to public
using (true);


create policy "Users can only create features for themselves"
on "public"."profile_features"
as permissive
for insert
to authenticated
with check ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = profile_features.profile_id))));


create policy "Users can only delete their own profile features"
on "public"."profile_features"
as permissive
for delete
to authenticated
using ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = profile_features.profile_id))));


create policy "Users can update their own profile_features"
on "public"."profile_features"
as permissive
for update
to authenticated
using ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = profile_features.profile_id))))
with check ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = profile_features.profile_id))));


create policy "admins have full control"
on "public"."profile_features"
as permissive
for all
to authenticated
using ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb))
with check ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb));


create policy "Enable authenticated users to create a profile with their id"
on "public"."profiles"
as permissive
for insert
to authenticated
with check ((auth.uid() = auth_id));


create policy "Enable read access for all users"
on "public"."profiles"
as permissive
for select
to public
using (true);


create policy "Users can update their own profile"
on "public"."profiles"
as permissive
for update
to authenticated
using ((auth.uid() = auth_id))
with check ((auth.uid() = auth_id));


create policy "admins have full control"
on "public"."profiles"
as permissive
for all
to authenticated
using ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb))
with check ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb));


create policy "Users can insert their own recurring drives"
on "public"."recurring_drives"
as permissive
for insert
to authenticated
with check ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = recurring_drives.driver_id))));


create policy "Users can see their own recurring drives"
on "public"."recurring_drives"
as permissive
for select
to authenticated
using ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = recurring_drives.driver_id))));


create policy "Users can update their own recurring drives"
on "public"."recurring_drives"
as permissive
for update
to authenticated
using ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = recurring_drives.driver_id))))
with check ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = recurring_drives.driver_id))));


create policy "admins have full control"
on "public"."recurring_drives"
as permissive
for all
to authenticated
using ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb))
with check ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb));


create policy "Users can only insert their own reports"
on "public"."reports"
as permissive
for insert
to authenticated
with check ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = reports.reporter_id))));


create policy "Users can read their own reports"
on "public"."reports"
as permissive
for select
to public
using ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = reports.reporter_id))));


create policy "admins have full control"
on "public"."reports"
as permissive
for all
to authenticated
using ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb))
with check ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb));


create policy "Enable read access for all users"
on "public"."reviews"
as permissive
for select
to public
using (true);


create policy "Users can only create reviews that they wrote"
on "public"."reviews"
as permissive
for insert
to authenticated
with check ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = reviews.writer_id))));


create policy "Users can update reviews that they wrote"
on "public"."reviews"
as permissive
for update
to authenticated
using ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = reviews.writer_id))))
with check (true);


create policy "admins have full control"
on "public"."reviews"
as permissive
for all
to authenticated
using ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb))
with check ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb));


create policy "admins have full control"
on "public"."ride_events"
as permissive
for all
to authenticated
using ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb))
with check ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb));


create policy "users can select events from rides they can see"
on "public"."ride_events"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM rides
  WHERE (rides.id = ride_events.ride_id))));


create policy "Users can create rides only for themselves"
on "public"."rides"
as permissive
for insert
to authenticated
with check ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = rides.rider_id))));


create policy "Users can see rides for their own drives"
on "public"."rides"
as permissive
for select
to authenticated
using ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id IN ( SELECT drives.driver_id
           FROM drives
          WHERE (drives.id = rides.drive_id))))));


create policy "Users can see their own rides"
on "public"."rides"
as permissive
for select
to authenticated
using ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = rides.rider_id))));


create policy "Users can update their own rides"
on "public"."rides"
as permissive
for update
to authenticated
using ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = rides.rider_id))))
with check ((auth.uid() IN ( SELECT profiles.auth_id
   FROM profiles
  WHERE (profiles.id = rides.rider_id))));


create policy "admins have full control"
on "public"."rides"
as permissive
for all
to authenticated
using ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb))
with check ((get_claim(auth.uid(), 'admin'::text) = '{"admin": "true"}'::jsonb));


CREATE TRIGGER update_ride_status_trigger AFTER UPDATE ON public.drives FOR EACH ROW EXECUTE FUNCTION update_ride_status();

CREATE TRIGGER recurring_drive_insert_trigger AFTER INSERT ON public.recurring_drives FOR EACH ROW EXECUTE FUNCTION recurring_drive_insert();

CREATE TRIGGER recurring_drive_update_trigger BEFORE UPDATE ON public.recurring_drives FOR EACH ROW EXECUTE FUNCTION recurring_drive_update();

CREATE TRIGGER ride_event_insert_trigger BEFORE INSERT ON public.ride_events FOR EACH ROW EXECUTE FUNCTION ride_event_insert();

CREATE TRIGGER create_chat_trigger BEFORE INSERT ON public.rides FOR EACH ROW EXECUTE FUNCTION create_chat();

CREATE TRIGGER create_ride_event_trigger AFTER INSERT OR UPDATE ON public.rides FOR EACH ROW EXECUTE FUNCTION create_ride_event();


set check_function_bodies = off;

CREATE OR REPLACE FUNCTION storage.extension(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
_filename text;
BEGIN
	select string_to_array(name, '/') into _parts;
	select _parts[array_length(_parts,1)] into _filename;
	-- @todo return the last part instead of 2
	return split_part(_filename, '.', 2);
END
$function$
;

CREATE OR REPLACE FUNCTION storage.filename(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$function$
;

CREATE OR REPLACE FUNCTION storage.foldername(name text)
 RETURNS text[]
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[1:array_length(_parts,1)-1];
END
$function$
;

create policy "Enable insert for authenticated users only"
on "storage"."objects"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "storage"."objects"
as permissive
for select
to public
using (true);



